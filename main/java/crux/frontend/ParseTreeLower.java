package crux.frontend;

import crux.frontend.ast.*;
import crux.frontend.ast.OpExpr.Operation;
import crux.frontend.pt.CruxBaseVisitor;
import crux.frontend.pt.CruxParser;
import crux.frontend.types.*;
import org.antlr.v4.runtime.ParserRuleContext;

import java.io.PrintStream;
import java.util.ArrayList;
import java.util.List;

/**
 * This class will convert the parse tree generated by ANTLR to AST It follows the visitor pattern
 * where declarations will be by DeclarationVisitor Class Statements will be resolved by
 * StatementVisitor Class Expressions will be resolved by ExpressionVisitor Class
 */

public final class ParseTreeLower {
    //(AN) Resolve each declaration, statement, and expression (referenced or de-referenced -> Usually arrays and other addresses)
    private final DeclarationVisitor declarationVisitor = new DeclarationVisitor();
    private final StatementVisitor statementVisitor = new StatementVisitor();
    private final ExpressionVisitor expressionVisitor = new ExpressionVisitor(true);
    private final ExpressionVisitor locationVisitor = new ExpressionVisitor(false);

    private final SymbolTable symTab;

    //(AN) Initializes symTable and starts tree
    public ParseTreeLower(PrintStream err)
    {
        symTab = new SymbolTable(err);
    }

    //(AN) Used to find beginning of line position
    private static Position makePosition(ParserRuleContext ctx)
    {
        var start = ctx.start;
        return new Position(start.getLine());
    }

    /**
     *
     * @return True if any errors
     */
    public boolean hasEncounteredError()
    {
        return symTab.hasEncounteredError();
    }

    /**
     * Lower top-level parse tree to AST
     *
     * @return a {@link DeclarationList} object representing the top-level AST.
     */
    public DeclarationList lower(CruxParser.ProgramContext program)
    {
        //public DeclarationList(Position position, List<Declaration> declarations)
        Position pos = makePosition(program);
        ArrayList<Declaration> dList = new ArrayList<>();

        for (int i = 0; i < program.declarationList().declaration().size(); i++)
        {
            if (program.declarationList().declaration(i) != null)
            {
                Declaration resolvedDeclaration = program.declarationList().declaration(i).accept(declarationVisitor);
                dList.add(resolvedDeclaration);
            }
        }
        return new DeclarationList(pos, dList);
    }

    /**
     * Lower statement list by lower individual statement into AST.
     *
     * @return a {@link StatementList} AST object.
     */
    private StatementList lower(CruxParser.StatementListContext statementList)
    {
        //public StatementList(Position position, List<Statement> statements)
        Position pos = makePosition(statementList);
        ArrayList<Statement> sList = new ArrayList<>();

        for (int i = 0; i < statementList.statement().size(); i++) {
            if (statementList.statement(i) != null) {
                Statement resolvedStatement = statementList.statement(i).accept(statementVisitor);
                sList.add(resolvedStatement);
            }
        }
        return new StatementList(pos, sList);
    }

    /**
     * Similar to {@link #lower(CruxParser.StatementListContext)}, but handling symbol table as well.
     *
     * @return a {@link StatementList} AST object.
     */
    //(AN) block calls list, so implement this function first
    private StatementList lower(CruxParser.StatementBlockContext statementBlock)
    {
        symTab.enter();
        StatementList list = lower(statementBlock.statementList());
        symTab.exit();
        return list;
    }

    /**
     * A parse tree visitor to create AST nodes derived from {@link Declaration}
     */
    private final class DeclarationVisitor extends CruxBaseVisitor<Declaration>
    {
        /**
         * Visit a parse tree variable declaration and create an AST {@link VariableDeclaration}
         *
         * @return an AST {@link VariableDeclaration}
         */


        //(AN) make position, create function symbol, enter new scope
        //add func parameters to symbol table, lower function body, create function node
        //exit scope, return functionDef node
        @Override
        public VariableDeclaration visitVariableDeclaration(CruxParser.VariableDeclarationContext ctx)
        {
            //public VariableDeclaration(Position position, Symbol symbol)
            Position pos = makePosition(ctx);
            String ctxType = ctx.type().getText();
            Type varType = new BoolType();
            if (ctxType.equalsIgnoreCase("int")) {
                varType = new IntType();
            }

            Symbol sym = symTab.add(pos, ctx.Identifier().getText(), varType);
            return new VariableDeclaration(pos, sym);
        }

        /**
         * Visit a parse tree array declaration and create an AST {@link ArrayDeclaration}
         *
         * @return an AST {@link ArrayDeclaration}
         */
        @Override public Declaration visitArrayDeclaration(CruxParser.ArrayDeclarationContext ctx)
        {
            //public ArrayDeclaration(Position position, Symbol symbol)
            Position pos = makePosition(ctx);
            String ctxType = ctx.type().Identifier().getText();

            Type base = new BoolType();
            if (ctxType.equalsIgnoreCase("int"))
            {
                base = new IntType();
            }

            //public ArrayType(long extent, Type base)
            long extent = Integer.parseInt(ctx.Integer().getText());
            ArrayType aType = new ArrayType(extent, base);

            Symbol sym = symTab.add(pos, ctx.Identifier().getText(), aType);
            return new ArrayDeclaration(pos, sym);
        }

        /**
         * Visit a parse tree function definition and create an AST {@link FunctionDefinition}
         *
         * @return an AST {@link FunctionDefinition}
         */
        @Override public Declaration visitFunctionDefinition(CruxParser.FunctionDefinitionContext ctx)
        {
            //public FunctionDefinition(Position position, Symbol symbol, List<Symbol> parameters, StatementList statements)
            Position pos = makePosition(ctx);
            String ctxType = ctx.type().getText();

            //Create function here (along w/globals)
            Type functionReturnType = new VoidType();
            if (ctxType.equalsIgnoreCase("bool"))
            {
                functionReturnType = new BoolType();
            }
            else if (ctxType.equalsIgnoreCase("int"))
            {
                functionReturnType = new IntType();
            }

            ArrayList<Type> typeList = new ArrayList<>(); //keeps track of argument types
            for(int i = 0; i < ctx.parameterList().parameter().size(); i++)
            {
                if (ctx.parameterList().parameter(i) != null)
                {
                    String type = ctx.parameterList().parameter(i).type().getText(); //type of argument as string
                    Type theType = new BoolType();
                    if (type.equalsIgnoreCase("int")) {
                        theType = new IntType();
                    }
                    typeList.add(theType);
                }
            }

            //Create function ast node
            FuncType fnType = new FuncType(new TypeList(typeList), functionReturnType); //function takes "type" parameters, returns funcReturn type
            Symbol funcSymbol = symTab.add(pos, ctx.Identifier().getText(), fnType); //adds newly created function as part of global scope

            //Enter a new scope
            symTab.enter();

            //Add all parameters
            ArrayList<Symbol> argsList = new ArrayList<>(); //keeps track of arguments
            for(int i = 0; i < ctx.parameterList().parameter().size(); i++)
            {
                if (ctx.parameterList().parameter(i) != null)
                {
                    Symbol singleSymbol = symTab.add(pos, ctx.parameterList().parameter(i).Identifier().getText(), typeList.get(i));
                    argsList.add(singleSymbol);

                }
            }
            //Lower statement blocks
            StatementList funcBody = lower(ctx.statementBlock().statementList()); //contents of the function

            //Exit scope
            symTab.exit();

            //Return function ast node
            return new FunctionDefinition(pos, funcSymbol, argsList, funcBody);
        }
    } //End of Declaration Visitor class

    /**
     * A parse tree visitor to create AST nodes derived from {@link Statement}
     */

    private final class StatementVisitor extends CruxBaseVisitor<Statement>
    {
        /**
         * Visit a parse tree variable declaration and create an AST {@link VariableDeclaration}. Since
         * {@link VariableDeclaration} is both {@link Declaration} and {@link Statement}, we simply
         * delegate this to
         * {@link DeclarationVisitor#visitArrayDeclaration(CruxParser.ArrayDeclarationContext)} which we
         * implement earlier.
         *
         * @return an AST {@link VariableDeclaration}
         */
        @Override public Statement visitVariableDeclaration(CruxParser.VariableDeclarationContext ctx)
        {
            //public VariableDeclaration(Position position, Symbol symbol)
            return declarationVisitor.visitVariableDeclaration(ctx);
        }

        /**
         * Visit a parse tree assignment statement and create an AST {@link Assignment}
         *
         * @return an AST {@link Assignment}
         */
        @Override public Statement visitAssignmentStatement(CruxParser.AssignmentStatementContext ctx)
        {
            //(AN) Notes from 1:17:00 of Tuesday 4/6 class

            //public Assignment(Position position, Expression location, Expression value)
            Position pos = makePosition(ctx);
            Expression location = null;

            if (ctx.designator() != null)
            {
                location = locationVisitor.visit(ctx.designator()); //value of lhs
            }

            Expression value = null;
            if (ctx.Assign() != null)
            {
                value = expressionVisitor.visit(ctx.expression0()); //value of rhs
            }
            return new Assignment(pos, location, value);
        }

        /**
         * Visit a parse tree call statement and create an AST {@link Call}. Since {@link Call} is both
         * {@link Expression} and {@link Statement}, we simply delegate this to
         * {@link ExpressionVisitor#visitCallExpression(CruxParser.CallExpressionContext)} that we will
         * implement later.
         *
         * @return an AST {@link Call}
         */
        @Override public Statement visitCallStatement(CruxParser.CallStatementContext ctx)
        {
            return expressionVisitor.visitCallExpression(ctx.callExpression());
        }

        /**
         * Visit a parse tree if-else branch and create an AST {@link IfElseBranch}. The template code
         * shows partial implementations that visit the then block and else block recursively before
         * using those returned AST nodes to construct {@link IfElseBranch} object.
         *
         * @return an AST {@link IfElseBranch}
         */
        @Override public Statement visitIfStatement(CruxParser.IfStatementContext ctx)
        {
            //public IfElseBranch(Position position, Expression condition, StatementList thenBlock, StatementList elseBlock)
            Position pos = makePosition(ctx);

            Expression condition = expressionVisitor.visit(ctx.expression0()); //expression guaranteed to exist
            StatementList thenBlock = new StatementList(pos, List.of()); //contents of thenBlock not guaranteed
            StatementList elseBlock = new StatementList(pos, List.of()); //contents of elseBlock not guaranteed
            for (int i = 0; i < ctx.statementBlock().size(); i++)
            {
                if (i == 0 && ctx.statementBlock(i) != null)
                {
                    thenBlock = lower(ctx.statementBlock(i));
                }
                else if (ctx.Else() != null)
                {
                    elseBlock = lower(ctx.statementBlock(i));
                }
            }
            return new IfElseBranch(pos, condition, thenBlock, elseBlock);
        }

        /**
         * Visit a parse tree while loop and create an AST {@link Loop}. You'll going to use a similar
         * techniques as {@link #visitIfStatement(CruxParser.IfStatementContext)} to decompose this
         * construction.
         *
         * @return an AST {@link Loop}
         */
        @Override public Statement visitLoopStatement(CruxParser.LoopStatementContext ctx)
        {
            //public Loop(Position position, StatementList body)
            Position pos = makePosition(ctx);
            StatementList body = lower(ctx.statementBlock());
            return new Loop(pos, body);
        }

        /**
         * Visit a parse tree return statement and create an AST {@link Return}. Here we show a simple
         * example of how to lower a simple parse tree construction.
         *
         * @return an AST {@link Return}
         */
        @Override public Statement visitReturnStatement(CruxParser.ReturnStatementContext ctx)
        {
            //public Return(Position position, Expression value)
            Position pos = makePosition(ctx);
            Expression value = ctx.expression0().accept(expressionVisitor);
            return new Return(pos, value);
        }

        /**
         * Creates a Break node
         */
        @Override public Statement visitBreakStatement(CruxParser.BreakStatementContext ctx)
        {
            //public Break(Position position)
            return new Break(makePosition(ctx));
        }

        /**
         * Creates a Continue node
         */
        @Override public Statement visitContinueStatement(CruxParser.ContinueStatementContext ctx)
        {
            //public Continue(Position position)
            return new Continue(makePosition(ctx));
        }
    } //End of Statement Visitor class

    private final class ExpressionVisitor extends CruxBaseVisitor<Expression>
    {
        private final boolean dereferenceDesignator;

        private ExpressionVisitor(boolean dereferenceDesignator) //constructor from beginning of PTL
        {
            this.dereferenceDesignator = dereferenceDesignator;
        }

        /**
         * Parse Expression0 to OpExpr Node Parsing the expression should be exactly as described in the
         * grammar
         */

        //TC finished this function
        @Override public Expression visitExpression0(CruxParser.Expression0Context ctx)
        {
            //(AN) Thursday 4/8 Lecture, Time: 19:00
            //expression0 : expression1 ( op0 expression1 )?
            //public OpExpr(Position position, Operation op, Expression left, Expression right)
            Position pos = makePosition(ctx);
            Expression left = visit(ctx.expression1(0)); //guaranteed to exist

            if (ctx.op0() != null) //if op exists, rhs exists, too
            {
                Operation op = Operation.GT; //default at greater than
                if (ctx.op0().GreaterEqual() != null)
                {
                    op = Operation.GE;
                }
                else if (ctx.op0().LesserEqual() != null)
                {
                    op = Operation.LE;
                }
                else if (ctx.op0().NotEqual() != null)
                {
                    op = Operation.NE;
                }
                else if (ctx.op0().Equal() != null)
                {
                    op = Operation.EQ;
                } else if (ctx.op0().LessThan() != null)
                {
                    op = Operation.LT;
                }
                Expression right = visit(ctx.expression1(1));
                return new OpExpr(pos, op, left, right);
            }
            return left;  //no operation after left
        }

        /**
         * Parse Expression1 to OpExpr Node Parsing the expression should be exactly as described in the
         * grammar
         */

        //TC finished this one
        @Override public Expression visitExpression1(CruxParser.Expression1Context ctx)
        {
            //expression1 : expression2 | expression1 op1 expression2;
            Position pos = makePosition(ctx);
            Expression right = visit(ctx.expression2()); //expression2 guaranteed

            if (ctx.op1() != null) //if op1 exists, so does expression1
            {
                Expression left = visit(ctx.expression1());
                Operation op = Operation.LOGIC_OR;
                if (ctx.op1().Add() != null)
                {
                    op = Operation.ADD;
                }
                else if (ctx.op1().Sub() != null)
                {
                    op = Operation.SUB;
                }
                return new OpExpr(pos, op, left, right);
            }
            return right; //expression2 is considered rhs
        }

        /**
         * Parse Expression2 to OpExpr Node Parsing the expression should be exactly as described in the
         * grammar
         */

        //TC finished function
        @Override public Expression visitExpression2(CruxParser.Expression2Context ctx)
        {
            //expression2 : expression3 | expression2 op2 expression3;
            Position pos = makePosition(ctx);
            Expression right = visit(ctx.expression3()); //same conditions as visitExpression1

            if (ctx.op2() != null)
            {
                Expression left = visit(ctx.expression2());
                Operation op = Operation.LOGIC_AND;
                if (ctx.op2().Mult() != null)
                {
                    op = Operation.MULT;
                }
                else if (ctx.op2().Div() != null)
                {
                    op = Operation.DIV;
                }
                return new OpExpr(pos, op, left, right);
            }
            return right; //expression3 is considered rhs
        }

        /**
         * Parse Expression3 to OpExpr Node Parsing the expression should be exactly as described in the
         * grammar
         */
        @Override public Expression visitExpression3(CruxParser.Expression3Context ctx)
        {
            //(AN) Thursday 4/8 Lecture, Time: 25:38
            //expression3 : '!' expression3 | '(' expression0 ')' | designator | callExpression | literal;
            if (ctx.Not() != null)
            {
                Expression left = visit(ctx.expression3());
                return new OpExpr(makePosition(ctx), Operation.LOGIC_NOT, left, null);
            }
            else if (ctx.OpenParen() != null)
            {
                return visit(ctx.expression0());
            }
            else if (ctx.designator() != null)
            {
                return visit(ctx.designator());
            }
            else if (ctx.callExpression() != null)
            {
                return visit(ctx.callExpression());
            }
            else if (ctx.literal() != null)
            {
                return visit(ctx.literal());
            }
            return null; //technically unreachable but here to ensure compilation
        }

        /**
         * Create an Call Node
         */
        @Override public Call visitCallExpression(CruxParser.CallExpressionContext ctx)
        {
            //public Call(Position position, Symbol callee, List<Expression> arguments)
            //callExpression : Identifier '(' expressionList ')';
            Position pos = makePosition(ctx);
            String symbolName = ctx.Identifier().getText(); //name of function

            Symbol callee = symTab.lookup(pos, symbolName); //look through symbol table if such function exists
            ArrayList<Expression> arguments = new ArrayList<>();

            for (int i = 0; i < ctx.expressionList().expression0().size(); i++)
            {
                if (ctx.expressionList().expression0(i) != null) //if an argument exists
                {
                    Expression e = visit(ctx.expressionList().expression0(i));
                    arguments.add(e);
                }
            }
            return new Call(pos, callee, arguments);
        }

        /**
         * visitDesignator will check for a name or ArrayAccess FYI it should account for the case when
         * the designator was de-referenced
         */
        @Override public Expression visitDesignator(CruxParser.DesignatorContext ctx)
        {
            //public ArrayAccess(Position position, Name base, Expression offset), public Name(Position position, Symbol symbol)
            Position pos = makePosition(ctx);
            Name base = new Name(pos, symTab.lookup(pos, ctx.Identifier().getText())); //lookup identifier and create name node
            ArrayAccess address; //address of array

            if (dereferenceDesignator)
            {
                if (ctx.expression0() != null)
                {
                    Expression offset = ctx.expression0().accept(expressionVisitor);
                    address = new ArrayAccess(pos, base, offset); //return array access
                    return new Dereference(pos, address);
                }
                else
                {
                    return new Dereference(pos, base);
                }
            }

            if(ctx.expression0() != null)
            {
                Expression offset = ctx.expression0().accept(expressionVisitor);
                address = new ArrayAccess(pos, base, offset); //return array access
                return address;
            }
            else
            {
                return base;
            }
        }

        /**
         * Create an Literal Node
         */
        //TC finished function
        @Override public Expression visitLiteral(CruxParser.LiteralContext ctx)
        {
            //4/8, Time: 29:29
            Position pos = makePosition(ctx);
            if (ctx.Integer() != null)
            {
                //public LiteralInt(Position position, long value)
                long value = Integer.parseInt(ctx.Integer().getText());
                return new LiteralInt(pos, value);
            }
            else if (ctx.True() != null)
            {
                return new LiteralBool(pos, true);
            }
            return new LiteralBool(pos, false);
        }
    }
}
